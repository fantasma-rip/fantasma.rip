<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta http-equiv="X-UA-Compatible" content="ie=edge">
		<title>experimento 5.0 - jun</title>
	</head>
	<body>
		<style>
			body{margin: 0; padding: 0; width: 100%;}
			canvas{width: 100%; height: 100%; cursor: grab;}
		</style>
		<!-- <script src="https://unpkg.com/dat.gui"></script> -->
		<script src="THREE.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="SVGLoader.js"></script>
		<script src="GPUComputationRenderer.js"></script>

		<!-- GPGPU shaders -->
		<script type="x-shader/x-fragment" id="computeShaderPosition">
			uniform float time;
			uniform float delta;
			uniform sampler2D windTexture;

			void main() {
				vec2 uv = gl_FragCoord.xy / resolution.xy;
				vec2 pos = texture2D(texturePosition, uv).xy;
				//vec3 vel = texture2D(textureVelocity, uv).xyz;
				//vec2 wind = ((texture2D(windTexture,  pos.xy).rg * vec2(0.58, 0.5)) - 0.25) * 10.0; // remapped
				vec2 wind = texture2D(windTexture,  pos.xy).rg;
				//vec2 wind = (texture2D(windTexture,  pos.xy).rg * 2.0) - 1.0;
				//wind = wind - vec2(0.46, 0.5);
				// dynamics
				vec2 deltaPos;
				if (pos.x < 0.5) {
					deltaPos = vec2(wind.x - 0.43, wind.y - 0.486) * delta * 2.0;
				} else {
					deltaPos = vec2(wind.x - 0.43, wind.y - 0.506) * delta * 2.0;
				}
				pos = pos + deltaPos;
				vec2 newPos = vec2(mod(pos.x + 1.0, 1.0), mod(pos.y + 1.0, 1.0)); // wrap around
				// output
				gl_FragColor = vec4(newPos.x, newPos.y, 0.0, 1.0);
			}
		</script>
		<script type="x-shader/x-fragment" id="computeShaderVelocity">
			uniform float time;
			uniform float delta;
			uniform sampler2D windTexture;

			void main() {
				vec2 uv = gl_FragCoord.xy / resolution.xy;
				vec3 pos = texture2D(texturePosition, uv).rgb;
				vec3 vel = texture2D(textureVelocity, uv).rgb; // particle mass on blue channel
				vec3 wind_lookup = texture2D(windTexture, pos.xy).rgb;
				vec2 wind = mix(vec2(-0.96), vec2(1.0), wind_lookup.rg) * 0.5; // remap

				// dynamics
				float mass = vel.b;
				vec2 acceleration = wind;
				vec2 position = pos.rg;
				vec2 velocity = vel.xy;
				velocity = acceleration;
				// output
				gl_FragColor = vec4(vec3(velocity, mass), length(acceleration));
			}
		</script>

		<!-- Star shaders -->
		<script type="x-shader/x-vertex" id="vertexStars">
			attribute float size;
			attribute vec3 customColor;

			varying vec3 vColor;

			void main() {
				vColor = customColor;
				vec4 mvPosition = modelViewMatrix * vec4(position.xyz, 1.0);
				gl_PointSize = size * (420.0 / -mvPosition.z);
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>
		<script type="x-shader/x-fragment" id="fragmentStars">
			uniform vec3 color;
			uniform sampler2D pointTexture;

			varying vec3 vColor;

			void main() {
				gl_FragColor = vec4(color * vColor, texture2D(pointTexture, gl_PointCoord).a);
				gl_FragColor = gl_FragColor;
			}
		</script>

		<!-- Wind shaders -->
		<script type="x-shader/x-vertex" id="vertexWind">
			attribute float vertexId;
			attribute vec3 customColor;
			attribute float size;

			uniform float time;
			uniform float delta;
			uniform sampler2D texturePosition;
			uniform sampler2D textureVelocity;
			uniform sampler2D windTexture;

			varying vec3 vColor;

			vec3 xy2xyz(vec2 coords, float rad) {
				// uv2xyz (rectangle to sphere)
				float theta = -0.3114 * 3.1416 * coords.x;
				float phi = 0.1269 * 6.2832 * coords.y;
				float radius = 1.18 + rad;
				float x = cos(theta) * sin(phi) * radius;
				float y = sin(theta) * sin(phi) * radius;
				float z = -cos(phi) * radius;
				vec3 pos = vec3(x, z, y);
				return pos;
			}
			void main() {
				vec3 pos = texture2D(texturePosition, uv).xyz;
				vec4 vel = texture2D(textureVelocity, uv);
				vec3 wind_height = texture2D(windTexture, pos.xy * vec2(1.003, 1.0)).xyz;
				vec3 wind_remapped = (wind_height - vec3(0.5, 0.5, 0.0)) * 2.0;
                                vec2 wind = texture2D(windTexture,  pos.xy).rg;
                                //wind = wind - 0.5;
				vColor = vec3(customColor.rg, customColor.b);
				pos.x = pos.x * 6.42;
				pos.y = pos.y * 3.94;
				vec4 mvPosition = modelViewMatrix * vec4(xy2xyz(pos.xy, (exp(wind_remapped.b * 0.2) / 2.718) * 2.0), 1.0); // 3D
				//vec4 mvPosition = modelViewMatrix * vec4(vec3(pos.xy, wind_remapped.b * 0.4) - vec3(3.21, 1.97, 0.0), 1.0); // 2D
				//vec4 mvPosition = modelViewMatrix * vec4(vec3(pos.xy, wind_remapped.b * 0.2) - vec3(0.0, 0.0, 0.0), 1.0); // TEST
				gl_PointSize = size * (6.0 / -mvPosition.z);
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>
		<script type="x-shader/x-fragment" id="fragmentWind">
			uniform float time;
			uniform float delta;
			uniform vec3 color;

			uniform sampler2D texturePosition;
			uniform sampler2D textureVelocity;
			uniform sampler2D pointTexture;

			varying vec3 vColor;

			void main() {
				gl_FragColor = vec4(color * vColor, texture2D(pointTexture, gl_PointCoord).a * 0.64);
				gl_FragColor = gl_FragColor;
			}
		</script>
		<script>
		// scene setup
		var width = window.innerWidth;
		var height = window.innerHeight;
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		var renderer = new THREE.WebGLRenderer({antialias: true});
		var controls = new THREE.OrbitControls(camera, renderer.domElement);
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);
		camera.position.z = 4.6;
		camera.position.y = 0.0;

		// window resizer
		window.addEventListener('resize',function(){
			width = window.innerWidth;
			height = window.innerHeight;
			renderer.setSize(width,height);
			camera.aspect= width / height;
			camera.updateProjectionMatrix();
		});

		// map values from 2D rectangle to 3D sphere
		var uv2xyz = function(coord, radius) {
			var theta = -0.3208 * 3.1416 * coord[0];
			var phi = 0.1222 * 6.2832 * coord[1];

			var x = Math.cos(theta) * Math.sin(phi) * radius;
			var y = Math.sin(theta) * Math.sin(phi) * radius;
			var z = -Math.cos(phi) * radius;
			var vertex = new THREE.Vector3(x, y, z);
			return vertex;
		};

		// particle variables
		var textureSize = 256;
		var dispersion = 2048.0;
		// wind
		var amountWind = textureSize * textureSize;
		var positionsWind = new Float32Array(amountWind * 4);
		var uvsWind = new Float32Array(amountWind * 2);
		var colorsWind = new Float32Array(amountWind * 3);
		var sizesWind = new Float32Array(amountWind);
		var idsWind = new Float32Array(amountWind);
		var vertexWind = new THREE.Vector4();
		var uvWind = new THREE.Vector2();
		var colorWind = new THREE.Color(0x008866);
		// starfield
		var amountStars = textureSize;
		var positionsStars = new Float32Array(amountStars * 3);
		var colorsStars = new Float32Array(amountStars * 3);
		var sizesStars = new Float32Array(amountStars);
		var vertexStars = new THREE.Vector3();
		var colorStars = new THREE.Color(0x668866);

		// initialize wind geometry
		for (var i = 0; i < amountWind; i++) {
			vertexWind.x = (Math.random());// * 6896.0;
			vertexWind.y = (Math.random());// * -4296.0;
			vertexWind.z = 0;
			vertexWind.w = 1;

			vertexWind.toArray(positionsWind, i * 4);
			colorWind.toArray(colorsWind, i * 3);
			sizesWind[i] = 1;
			idsWind[i] = i;
		}
		var p = 0; // calculate compute shader textures uvs
		for (var j = 0; j < textureSize; j++) {
			for (var i = 0; i < textureSize; i++) {
				uvsWind[p++] = i / (textureSize - 1);
				uvsWind[p++] = j / (textureSize - 1);
			}
		}
		var geometryWind = new THREE.BufferGeometry();
		geometryWind.setAttribute('vertexId', new THREE.BufferAttribute(idsWind, 1));
		geometryWind.setAttribute('position', new THREE.BufferAttribute(positionsWind, 4));
		geometryWind.setAttribute('uv', new THREE.BufferAttribute(uvsWind, 2));
		geometryWind.setAttribute('customColor', new THREE.BufferAttribute(colorsWind, 3));
		geometryWind.setAttribute('size', new THREE.BufferAttribute(sizesWind, 1));

		// initialize stars geometry
		for (var i = 0; i < amountStars; i++) {
			vertexStars.x = (Math.random() * 2 - 1) * dispersion;
			vertexStars.y = (Math.random() * 2 - 1) * dispersion;

			vertexStars = uv2xyz([vertexStars.x, vertexStars.y], 100.0);

			vertexStars.toArray(positionsStars, i * 3);
			colorStars.toArray(colorsStars, i * 3);
			sizesStars[i] = Math.random() * 1.4;
		}
		var geometryStars = new THREE.BufferGeometry();
		geometryStars.setAttribute('position', new THREE.BufferAttribute(positionsStars, 3));
		geometryStars.setAttribute('customColor', new THREE.BufferAttribute(colorsStars, 3));
		geometryStars.setAttribute('size', new THREE.BufferAttribute(sizesStars, 1));

		// shader init
		// wind shader parameters
		var time = 0.0;
		var windShaderUniforms = {
			time: {type: "f", value: 0.0},
			delta: {type: "f", value: 0.0},
			color: {value: new THREE.Color(0xffffff)},
			pointTexture: {value: new THREE.TextureLoader().load("circle_alpha.png")},
			windTexture: {value: new THREE.TextureLoader().load("windRG_heightB.png")},
			texturePosition: {value: null},
			textureVelocity: {value: null}
		};
		// wind material
		var materialWind = new THREE.ShaderMaterial({
			uniforms: windShaderUniforms,
			vertexShader: document.getElementById('vertexWind').textContent,
			fragmentShader: document.getElementById('fragmentWind').textContent,
			blending: THREE.AdditiveBlending,
			depthTest: false,
			transparent: true
		});
		// stars shader parameters
		var starsShaderUniforms = {
			time: {type: "f", value: 0.0},
			delta: {type: "f", value: 0.0},
			color: {type: "v3", value: new THREE.Color(0xffffff)},
			pointTexture: {value: new THREE.TextureLoader().load("circle_alpha.png")}
		};
		// stars material
		var materialStars = new THREE.ShaderMaterial({
			uniforms: starsShaderUniforms,
			vertexShader: document.getElementById('vertexStars').textContent,
			fragmentShader: document.getElementById('fragmentStars').textContent,
			blending: THREE.AdditiveBlending,
			depthTest: false,
			transparent: true
		});

		// instance particle objects and add them to the scene
		var wind = new THREE.Points(geometryWind, materialWind);
		var stars = new THREE.Points(geometryStars, materialStars);
		scene.add(wind);
		scene.add(stars);

		// earth's coastline mesh group
		var coastline = new THREE.Group();
		// instantiate SVG loader
		var svgLoader = new THREE.SVGLoader();
		// load SVG coastline map
		svgLoader.load(
			'coastline.svg', // resource URL
			function (data) { // called on load
				var test = false;
				var paths = data.paths;
				// for every path
				for (var i = 0; i < paths.length; i ++) {
					var path = paths[i];
					var path_points = path.currentPath.getPoints();
					var points = [];
					var points2D = [];
					// for every coordinate
					for (var j = 0; j < path_points.length; j++) {
						var lon_lat = [path_points[j].x / 1076.0, path_points[j].y / 1076.0]; // size adjustment before mapping to sphere
						// push vertex into point buffer
						points.push(uv2xyz(lon_lat, 2.0));
						points2D.push((new THREE.Vector3(lon_lat[0] - 3.21, 0.0, lon_lat[1] - 1.97)).divideScalar(1.0));
					}
					// generate path mesh and add to group
					var material = new THREE.LineBasicMaterial({color: 0x00ff88});
					var geometry = new THREE.BufferGeometry().setFromPoints(points);
					var loop = new THREE.LineLoop(geometry, material);
					loop.rotateX(1.57); // correct sphere orientation by 90 deg
					coastline.add(loop);
				}
				// add group to scene
				scene.add(coastline);
				console.log(scene);
			},
			// called when loading
			function (xhr) {
				console.log('File loaded.');
			},
			function (error) { // called on errors
				console.log('An error ocurred while loading SVG file.');
			}
		);

		// GPGPU initialization
		var last = performance.now(); // for delta calulation
		var gpuCompute;
		var velocityVariable;
		var positionVariable;
		var positionUniforms;
		var velocityUniforms;

		// GPGPU setup
		gpuCompute = new THREE.GPUComputationRenderer(textureSize, textureSize, renderer);
		var dtPosition = gpuCompute.createTexture();
		var dtVelocity = gpuCompute.createTexture();

		// pre-fill computation textures
		var posDataArray = dtPosition.image.data;
		for (var k = 0, kl = posDataArray.length; k < kl; k += 4) {
			posDataArray[k + 0] = positionsWind[k + 0]; // copy positions from positionWind
			posDataArray[k + 1] = positionsWind[k + 1];
			posDataArray[k + 2] = positionsWind[k + 2];
			posDataArray[k + 3] = 1;
		}
		var velDataArray = dtVelocity.image.data;
		for (var k = 0, kl = velDataArray.length; k < kl; k += 4) {
			velDataArray[k + 0] = 0.0; // wind x velocity;
			velDataArray[k + 1] = 0.0; // wind y velocity;
			velDataArray[k + 2] = (Math.random() * 0.7) + 0.3; // particle mass;
			velDataArray[k + 3] = 1;
		}
		// computation variables init
		positionVariable = gpuCompute.addVariable("texturePosition", document.getElementById('computeShaderPosition').textContent, dtPosition);
		velocityVariable = gpuCompute.addVariable("textureVelocity", document.getElementById('computeShaderVelocity').textContent, dtVelocity);
		velocityVariable.wrapS = THREE.RepeatWrapping;
		velocityVariable.wrapT = THREE.RepeatWrapping;
		positionVariable.wrapS = THREE.RepeatWrapping;
		positionVariable.wrapT = THREE.RepeatWrapping;
		gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);
		gpuCompute.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);
		positionUniforms = positionVariable.material.uniforms;
		velocityUniforms = velocityVariable.material.uniforms;

		// computation shaders uniform declaration
		positionUniforms["time"] = {value: 0.0};
		positionUniforms["delta"] = {value: 0.0};
		positionUniforms["windTexture"] = {value: new THREE.TextureLoader().load("windRG_heightB.png")};
		velocityUniforms["time"] = {value: 1.0};
		velocityUniforms["delta"] = {value: 0.0};
		velocityUniforms["windTexture"] = {value: new THREE.TextureLoader().load("windRG_heightB.png")};

		var error = gpuCompute.init();
		if (error !== null) {
				console.error(error);
		}

		// DEBUGGING
		console.log(dtPosition);
		console.log(dtVelocity);
		console.log(positionVariable);
		console.log(velocityVariable);

		// animation logic ticks
		var update = function() {
		}; // using shaders instead!

		// objects to screen
		var render = function() {
			// get time variables
			var now = performance.now();
			var delta = (now - last) / 1000; // variable delta to support different hz
			if (delta > 1) delta = 1; // safety cap on large deltas
			last = now;
			// update time uniforms
			positionUniforms["time"].value = now;
			positionUniforms["delta"].value = delta;
			velocityUniforms["time"].value = now;
			velocityUniforms["delta"].value = delta;
			windShaderUniforms["time"].value = now;
			windShaderUniforms["delta"].value = delta;
			starsShaderUniforms["time"].value = now;
			starsShaderUniforms["delta"].value = delta;
			// compute new velocities and positions
			gpuCompute.compute();
			// update computation textures
			windShaderUniforms["texturePosition"].value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
			windShaderUniforms["textureVelocity"].value = gpuCompute.getCurrentRenderTarget(velocityVariable).texture;
			// render to screen
			renderer.render(scene, camera);
		};

		// animation tick/render loop
		var loop = function() {
			requestAnimationFrame(loop);
			update();
			render();
		};
		loop();
		</script>
	</body>
</html>

